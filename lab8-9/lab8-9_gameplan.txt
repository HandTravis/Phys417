## Understanding the data ##
input shape: [1, 2, 4096]
structure: each of the 2048 entries has 2 sensors at a sampling rate of 4096 for 1 sec
obvious patterns: no EM waves following BBH, some EM waves following CCSN, glitch has relatively large disparity between L1 and H1
dataset is very symmetrical, no apparent corruption or size mismatch

## Understanding the task ##
goal: classification
signficance: identifying origin of gravitational wave helps us to evaluate astrophysical models, improve rare event detection
evaluation metric: 
good performance threshold: > 90% test accuracy
baseline to compare after meeting performance: 

## Developing an initial plan ##
input shape: [1, 2, 4096]
output shape: 4 (classification of BBH, CCSN, glitch, background)
preprocessing steps: bandpass filter, whitening, spectrogram? see lecture 6 slides
Model type: RNN, 1D CNN
Loss function: CEL
Evaluation plan:



2nd model:

import torch
import torch.nn as nn
import torch.nn.functional as F

class InceptionBlock1D(nn.Module):
    def __init__(self, in_channels, out_channels):
        super(InceptionBlock1D, self).__init__()
        self.branch1 = nn.Conv1d(in_channels, out_channels, kernel_size=1, padding=0)

        self.branch3 = nn.Conv1d(in_channels, out_channels, kernel_size=3, padding=1)

        self.branch5 = nn.Conv1d(in_channels, out_channels, kernel_size=5, padding=2)

        self.pool = nn.MaxPool1d(kernel_size=3, stride=1, padding=1)
        self.branch_pool = nn.Conv1d(in_channels, out_channels, kernel_size=1)

    def forward(self, x):
        b1 = self.branch1(x)
        b3 = self.branch3(x)
        b5 = self.branch5(x)
        bp = self.branch_pool(self.pool(x))
        return torch.cat([b1, b3, b5, bp], dim=1)  # shape: [B, 4*out_channels, L]
    

class GWClassifier2(nn.Module):

    def __init__(self, in_channels=2, base_channels=16, num_classes=4):
        super(GWClassifier2, self).__init__()
        self.incept1 = InceptionBlock1D(in_channels, base_channels)  # output: [B, 64, 4096]
        self.bn1 = nn.BatchNorm1d(4 * base_channels)
        self.incept2 = InceptionBlock1D(4 * base_channels, base_channels)  # output: [B, 64, 4096]
        self.bn2 = nn.BatchNorm1d(4 * base_channels)
        self.pool = nn.AdaptiveAvgPool1d(1)  # shape: [B, 64, 1]
        self.fc = nn.Linear(4 * base_channels, num_classes)

    def forward(self, x):
        x = self.bn1(self.incept1(x))
        x = F.relu(x)
        x = self.bn2(self.incept2(x))
        x = F.relu(x)
        x = self.pool(x).squeeze(-1)  # shape: [B, 64]
        x = self.fc(x)
        return x